/*
1.
Find the movie titles, taglines, and directors for the top 5 popular movies.

Return the columns 'original_title', 'tagline', and 'director'.
Dataset description for movies table:

1) id - tmdb movie id

2) imdb_id - imdb movie id

3) popularity -A numeric quantity specifying the movie's popularity.

4) budget -The budget in which the movie was made.

5) revenue - The worldwide revenue generated by the movie.

6) original_title- The title of the movie

7) cast - The name of the lead and supporting actors.

8) homepage - A link to the homepage of the movie.

9) director - The name of the director of the movie

10) tagline - Movie's tagline.

11) keywords -The keywords or tags related to the movie.

12) overview -A brief description of the movie.

13) runtime -The running time of the movie in minutes.

14) genres -The genres of the movies

15) production_companies-The production house of the movie.

16) release_date -the date on which it was released.

17) vote_count -the count of votes received.

18) vote_average - average ratings the movie received.

19) release_year - the year on which it was released

Hints:
STEP 1: Select the columns original_title, tagline, and director from the table movies.

select original_title, tagline, director from movies;

STEP 2: Order the column popularity in descending order to get the highest to lowest popularity.

select original_title, tagline, director from movies order by popularity desc;

STEP 3: Use the limit to display only the top 5 popular movies.

Solution approach:
Write SQL query that retrieves the product_id from the products table based on certain conditions. It retrieves the product_id for products where the low_fats column is ‘Y’ (indicating low fats) and the recyclable column is ‘Y’ (indicating recyclable). The result set is ordered by the product_id column in ascending order.

Step by step solution appraoch :

SELECT product_id:
This specifies the column to be selected in the result set. It includes only the product_id column from the products table.

FROM products:
This indicates that the data is being retrieved from the products table.

WHERE low_fats = 'Y' AND recyclable = 'Y':
This filters the rows based on certain conditions. It includes only those rows where the low_fats column is ‘Y’ and the recyclable column is ‘Y’.

ORDER BY product_id:
This specifies the ordering of the result set. It sorts the rows based on the product_id column in ascending order.
*/
Select original_title, tagline, director
from movies
order by popularity desc
limit 5;
/*
2.
Write a query to find the ids of products that are both low-fat and recyclable.

Return the result table ordered by product_id in ascending order.
Explanation:

Only products 1 and 3 are both low-fat and recyclable.

Hints:
Write SQL query that selects the product_id from the “products” table where both the low_fats column is ‘Y’ and the recyclable column is ‘Y’. The result is ordered by the product_id in ascending order.

The SELECT statement specifies the column to be retrieved: product_id.

The FROM clause specifies the table name as “products”.

The WHERE clause filters the rows based on the conditions that the low_fats column is ‘Y’ and the recyclable column is ‘Y’. The = operator is used for comparison.

The ORDER BY clause sorts the result set in ascending order based on the product_id column.

Solution approach:
Write SQL query that retrieves the product_id from the products table based on certain conditions. It retrieves the product_id for products where the low_fats column is ‘Y’ (indicating low fats) and the recyclable column is ‘Y’ (indicating recyclable). The result set is ordered by the product_id column in ascending order.

Step by step solution appraoch :

SELECT product_id:
This specifies the column to be selected in the result set. It includes only the product_id column from the products table.

FROM products:
This indicates that the data is being retrieved from the products table.

WHERE low_fats = 'Y' AND recyclable = 'Y':
This filters the rows based on certain conditions. It includes only those rows where the low_fats column is ‘Y’ and the recyclable column is ‘Y’.

ORDER BY product_id:
This specifies the ordering of the result set. It sorts the rows based on the product_id column in ascending order.
*/
select product_id
from products
where low_fats = 'Y'
AND recyclable = 'Y'
order by product_id;
/*
3.
Write a query to fetch customer details like customerName, phone, addressLine1, city, state, and postalCode who are not from Germany.

Return the result ordered by customerName in ascending order.
*/
select customerName, phone, addressline1, city, state, postalcode
from customers
where country <> 'Germany'
order by customerName;
/*
4.
Write an SQL query to report the patient_id who have Type I Diabetes. Type I Diabetes always starts with DIAB1 prefix.

Return the results ordered by patient_id in ascending order.

Hints:
Use like operator
Extra care when two words are there.

solution approach:
Check for prefix starting with DIAB1
Use Like operator
*/
select patient_id
from patients
 where conditions like '% DIAB1%'
 or conditions like 'DIAB1%'
order by patient_id;
/*
5.
Find the details of the movies that are released between the years 2012-2015 i.e., (Including 2012 and 2015).

Return the columns 'original_title', 'genres', 'vote_average', and 'revenue'.
Return the result ordered by original_title in ascending order.
Dataset description for movies table:

1) id - tmdb movie id

2) imdb_id - imdb movie id

3) popularity -A numeric quantity specifying the movie's popularity.

4) budget -The budget in which the movie was made.

5) revenue - The worldwide revenue generated by the movie.

6) original_title- The title of the movie

7) cast - The name of the lead and supporting actors.

8) homepage - A link to the homepage of the movie.

9) director - The name of the director of the movie

10) tagline - Movie's tagline.

11) keywords -The keywords or tags related to the movie.

12) overview -A brief description of the movie.

13) runtime -The running time of the movie in minutes.

14) genres -The genres of the movies

15) production_companies-The production house of the movie.

16) release_date -the date on which it was released.

17) vote_count -the count of votes received.

18) vote_average - average ratings the movie received.

19) release_year - the year on which it was released.

Hints:
STEP 1: Select the columns original_title, genres, vote_average, and revenue from the movies table.

select original_title, genres, vote_average, revenue from movies;

Approach 1:

STEP 2: Use the where clause and filter the records based on the column release_year that are released between 2012 - 2015.

Approach 2:

STEP 2: Use the ‘between’ operator in the where clause and filter the records based on the column release_year that are released between 2012 - 2015.

*/
STEP 1: Select the columns original_title, genres, vote_average, and revenue from the movies table.

select original_title, genres, vote_average, revenue from movies;

-- Approach 1:

-- STEP 2: Use the where clause and filter the records based on the column release_year that are released between 2012 - 2015.

select original_title, genres, vote_average, revenue 
from movies 
where release_year >= 2012 and 
release_year <= 2015
order by original_title;
Approach 2:

-- STEP 2: Use the ‘between’ operator in the where clause and filter the records based on the column release_year that are released between 2012 - 2015.

select original_title, genres, vote_average, revenue 
from movies 
where release_year
between 2012 and 2015
order by original_title;

/*
6.
Write a SQL query to sort the olympic table according to the following rules:

The country with more gold medals should come first.
If there is a tie in the no. of gold medals, the country with more silver medals should come first.
If there is a tie in the no. of silver medals, the country with more bronze medals should come first.
If there is a tie in the no. of bronze medals as well, then the countries with the tie are sorted in ascending order lexicographically.

Explanation:

The tie between China and USA is broken by their lexicographical names.
Since "China" is lexicographically smaller than "USA", it comes first.
Israel comes before Egypt because it has more bronze medals.

Hints:
Step 1: Select the ‘country’, ‘gold_medals’, ‘silver_medals’, and ‘bronze_medals’ columns from the olympic table.

Step 2:
Sort the result set using the ORDER BY clause in the following manner -

First in descending order of `gold_medals` using the DESC keyword.
Then in descending order of `silver_medals` using the DESC keyword.
Then in descending order of `bronze_medals` using the DESC keyword.
Finally in acsending order of `country` using the ASC keyword.

Solution Approach:'Write SQL query that retrieves information about countries participating in the Olympics from the olympic table. It selects the country, gold_medals, silver_medals, and bronze_medals columns. The result set is ordered based on the number of gold medals in descending order, followed by the number of silver medals in descending order, the number of bronze medals in descending order, and finally, the country name in ascending order.

Step by step solution appraoch :

SELECT country, gold_medals, silver_medals, bronze_medals:
This specifies the columns to be selected in the result set. It includes the country, gold_medals, silver_medals, and bronze_medals columns from the olympic table.

Indicates that the data is being retrieved from the olympic table.

ORDER BY gold_medals DESC, silver_medals DESC, bronze_medals DESC, country ASC:

This defines the sorting order of the result set. It first sorts the rows based on the number of gold medals (gold_medals) in descending order. If there are ties, it then sorts based on the number of silver medals (silver_medals) in descending order. If there are still ties, it further sorts based on the number of bronze medals (bronze_medals) in descending order. Finally, if there are still ties, it sorts the countries (country) in ascending order.

Solution approach:
Write SQL query that retrieves information about countries participating in the Olympics from the olympic table. It selects the country, gold_medals, silver_medals, and bronze_medals columns. The result set is ordered based on the number of gold medals in descending order, followed by the number of silver medals in descending order, the number of bronze medals in descending order, and finally, the country name in ascending order.

Step by step solution appraoch :

SELECT country, gold_medals, silver_medals, bronze_medals:
This specifies the columns to be selected in the result set. It includes the country, gold_medals, silver_medals, and bronze_medals columns from the olympic table.

Indicates that the data is being retrieved from the olympic table.

ORDER BY gold_medals DESC, silver_medals DESC, bronze_medals DESC, country ASC:

This defines the sorting order of the result set. It first sorts the rows based on the number of gold medals (gold_medals) in descending order. If there are ties, it then sorts based on the number of silver medals (silver_medals) in descending order. If there are still ties, it further sorts based on the number of bronze medals (bronze_medals) in descending order. Finally, if there are still ties, it sorts the countries (country) in ascending order.

*/
SELECT country, gold_medals, silver_medals, bronze_medals
FROM olympic
ORDER BY 
gold_medals DESC,
silver_medals DESC,
bronze_medals DESC,
country ASC;

/*
7.
Write a query to list down all the movies along with their details that have keywords like 'sport' or 'sequel' or 'suspense'.

Note:

Return the columns 'original_title', 'director', 'genres', 'cast', 'budget', 'revenue', 'runtime', and 'vote_average'.
Return the columns ordered by original_title in ascending order.
Dataset description for 'movies' table:

id - tmdb movie id
imdb_id - imdb movie id
popularity - A numeric quantity specifying the movie popularity.
budget - The budget in which the movie was made.
revenue - The worldwide revenue generated by the movie.
original_title - The title of the movie
cast - The name of the lead and supporting actors.
homepage - A link to the homepage of the movie.
director - The name of the director of the movie
tagline - Movie tagline.
keywords - The keywords or tags related to the movie.
overview - A brief description of the movie.
runtime - The running time of the movie in minutes.
genres - The genres of the movies
production_companies - The production house of the movie.
release_date - the date on which it was released.
vote_count - the count of votes received.
vote_average - average ratings the movie received.
release_year - the year in which it was released.

Hints:
STEP 1: Select the columns original_title, director, genres, cast, budget, revenue, runtime, and vote_average from the movies table.

STEP 2: Use the ‘LIKE’ operator and filter the records based on the keywords column using the WHERE clause, if the keywords are sport, sequel, suspense.

STEP 3: Use the ‘OR’ operator between the keywords to satisfy the conditions.

Solution Apporoach:
Write SQL query that retrieves information about movies from the movies table based on certain criteria.
It selects the original_title, director, genres, cast, budget, revenue, runtime, and vote_average columns. The result set is filtered using the WHERE clause to include movies that have keywords related to sports, sequels, or suspense. The result set is then ordered by the original_title column in ascending order.

Step by step solution appraoch :

SELECT original_title, director, genres, cast, budget, revenue, runtime, vote_average:
This specifies the columns to be selected in the result set. It includes the original_title, director, genres, cast, budget, revenue, runtime, and vote_average columns from the movies table.

FROM movies:
This indicates that the data is being retrieved from the movies table.

WHERE keywords LIKE '%sport%' OR keywords LIKE '%sequel%' OR keywords LIKE '%suspense%':
This filters the rows based on certain conditions. It uses the LIKE operator along with the % wildcard to match movies that have keywords containing “sport”, “sequel”, or “suspense”. The OR operator combines the conditions, so if any of the conditions are met, the row is included in the result set.

ORDER BY original_title:
This specifies the ordering of the result set. It sorts the rows based on the original_title column in ascending order.
*/
SELECT 
 original_title, 
 director, 
 genres, cast, budget, revenue, runtime, vote_average 
FROM movies 
WHERE
 keywords LIKE '%sport%' OR 
 keywords LIKE '%sequel%' OR 
 keywords LIKE '%suspense%'
ORDER BY original_title;

/*
8.
Write a query to get the list of city names starting with vowels (i.e., a, e, i, o, or u) from station table.

The result should not contain duplicate values.

Return the result table ordered by city in ascending order.

Explanation: The above table has unique city names starting with vowels (i.e., a, e, i, o, or u) and is ordered by city in ascending order.

Hints:
Write SQL query that selects distinct cities from the “station” table that start with the vowels ‘a’, ‘e’, ‘i’, ‘o’, or ‘u’.
The result is ordered alphabetically by the city names.

The SELECT DISTINCT statement retrieves distinct values from the “city” column.

The FROM clause specifies the table name as “station”.

The WHERE clause filters the rows based on the condition that the city starts with any of the specified vowels using the LIKE operator and pattern matching with the ‘%’ wildcard.

The ORDER BY clause sorts the result set in ascending order based on the city names.
*/
-- Approach 1:

-- SELECT distinct(city) FROM station
WHERE city LIKE 'a%' 
OR city LIKE 'e%' 
OR city LIKE 'i%' 
OR city LIKE 'o%' 
OR city LIKE 'u%'
ORDER BY city;

-- Approach 2:

SELECT DISTINCT(city)
FROM station
WHERE SUBSTR(city, 1, 1) IN ('A', 'E' , 'I', 'O', 'U')
ORDER BY city;

/*
9.
Write a query to report the IDs of the low-quality problems.

A problem is low-quality if the like percentage of the problem (the number of likes divided by the total number of votes) is strictly less than 60%.

Return the result table ordered by problem_id in ascending order.

Explanation:

The like percentages are as follows:

Problem 1: (4446 / (4446 + 2760)) * 100 = 61.69858%
Problem 6: (1290 / (1290 + 425)) * 100 = 75.21866%
Problem 7: (8569 / (8569 + 6086)) * 100 = 58.47151%
Problem 10: (9002 / (9002 + 7446)) * 100 = 54.73006%
Problem 11: (2677 / (2677 + 8659)) * 100 = 23.61503%
Problem 13: (2050 / (2050 + 4164)) * 100 = 32.99002%
Problems 7, 10, 11, and 13 are low-quality problems because their like percentages are less than 60%

Hints:
Write sql query that selects the “problem_id” column from the “problems” table based on a condition and sorts the result by the “problem_id” column.

write SELECT statement that specifies the “problem_id” column to be retrieved from the table.

specify table from which we want to retrieve the data. In this case, it’s the “problems” table.

use WHERE clause that filters the rows based on a specific condition. Here, we are calculating the percentage of likes as a ratio of total likes and dislikes (likes / (likes + dislikes)) and then comparing it to 60. Rows are selected where this percentage is less than 60.

use ORDER BY clause, which is used to sort the result set based on a specific column. In this case, we are sorting the result set in ascending order based on the “problem_id” column.

Solution Approach:
SELECT problem_id 
This is the SELECT statement that specifies the “problem_id” column to be retrieved from the table.

 FROM problems
This indicates the table from which we want to retrieve the data. In this case, it’s the “problems” table.

 WHERE ((likes/(likes+dislikes))*100) < 60
This is the WHERE clause that filters the rows based on a specific condition. Here, we are calculating the percentage of likes as a ratio of total likes and dislikes (likes / (likes + dislikes)) and then comparing it to 60. Rows are selected where this percentage is less than 60.

 ORDER BY problem_id
This is the ORDER BY clause, which is used to sort the result set based on a specific column. In this case, we are sorting the result set in ascending order based on the “problem_id” column.

Scaler approach:
SELECT problem_id 
FROM problems 
WHERE ((likes/(likes+dislikes))*100) < 60
ORDER BY problem_id;
*/
select problem_id 
-- , likes, dislikes, (likes+dislikes) as total, Round(likes/(likes+dislikes)*100) as percentage
from problems
where Round(likes/(likes + dislikes)*100)<60
order by problem_id;
